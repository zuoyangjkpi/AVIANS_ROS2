# 无人机低级控制器架构与实现原理

## 概述

低级控制器系统是NMPC高级控制器与Gazebo仿真器之间的桥梁，负责将NMPC输出的抽象控制指令转换为具体的无人机执行指令。系统采用分层架构设计，包含三个主要控制器：航点控制器(Waypoint Controller)、姿态控制器(Attitude Controller)和速度控制器(Velocity Controller)。

## 系统架构

### 1. 整体控制流程

```
NMPC控制器 (高级控制层)
    ↓ [航点指令, 姿态指令]
航点控制器 (位置控制层)
    ↓ [速度设定点]
姿态控制器 (姿态控制层)
    ↓ [角速度设定点]
速度控制器 (执行控制层)
    ↓ [cmd_vel指令]
Gazebo仿真器 (物理执行层)
```

### 2. 控制器层次结构

```
低级控制器系统
├── 航点控制器 (waypoint_controller.py)
│   ├── 输入: PoseStamped (/drone/control/waypoint_command)
│   ├── 输出: TwistStamped (/drone/control/velocity_setpoint)
│   ├── 功能: 位置PID控制，航点跟踪
│   └── 频率: 50 Hz
├── 姿态控制器 (attitude_controller.py)
│   ├── 输入: Vector3Stamped (/drone/control/attitude_command)
│   ├── 输出: Vector3Stamped (/drone/control/angular_velocity_setpoint)
│   ├── 功能: 姿态PID控制，角度跟踪
│   └── 频率: 100 Hz
└── 速度控制器 (velocity_controller.py)
    ├── 输入: TwistStamped, Vector3Stamped
    ├── 输出: Twist (/X3/cmd_vel)
    ├── 功能: 速度混合控制，最终指令输出
    └── 频率: 50 Hz
```

## 航点控制器 (Waypoint Controller)

### 1. 功能概述

航点控制器负责接收NMPC的位置指令，通过PID控制算法计算所需的速度指令，实现精确的位置跟踪。

### 2. 输入输出接口

```python
# 输入话题
'/drone/control/waypoint_command'    # PoseStamped - 目标航点
'/X3/odometry'                       # Odometry - 当前位置状态
'/drone/control/waypoint_enable'     # Bool - 控制器启用状态

# 输出话题
'/drone/control/velocity_setpoint'   # TwistStamped - 速度设定点
'/drone/control/waypoint_reached'    # Bool - 航点到达状态
```

### 3. PID控制算法实现

```python
def control_loop(self):
    # 位置误差计算
    position_error = target_waypoint - current_pose

    # PID控制器参数 (参考PX4 v1.16.0)
    kp = [kp_xy, kp_xy, kp_z]         # 位置比例增益
    ki = [ki_xy, ki_xy, ki_z]         # 位置积分增益
    kd = [kd_xy, kd_xy, kd_z]         # 位置微分增益

    # 积分项计算 (防积分饱和)
    position_error_integral += position_error * dt
    position_error_integral = clip(position_error_integral, -max_integral, max_integral)

    # 微分项计算
    error_derivative = (position_error - position_error_previous) / dt

    # PID输出计算
    velocity_command = (kp * position_error +
                       ki * position_error_integral +
                       kd * error_derivative)

    # 速度限制
    max_vel = [max_velocity_xy, max_velocity_xy, max_velocity_z]
    velocity_command = clip(velocity_command, -max_vel, max_vel)
```

### 4. 参数配置

```python
# 控制频率
control_frequency: 50.0    # Hz

# 控制精度
position_tolerance: 0.2    # meters - 位置到达容差
velocity_tolerance: 0.1    # m/s - 速度到达容差

# PID增益 (类似PX4参数)
kp_xy: 1.0                # 水平位置比例增益
ki_xy: 0.05               # 水平位置积分增益
kd_xy: 0.01               # 水平位置微分增益
kp_z: 1.0                 # 垂直位置比例增益
ki_z: 0.05                # 垂直位置积分增益
kd_z: 0.01                # 垂直位置微分增益

# 速度限制
max_velocity_xy: 3.0      # m/s - 水平最大速度
max_velocity_z: 1.5       # m/s - 垂直最大速度
```

### 5. 航点到达判断

```python
def check_waypoint_reached(self):
    position_error_magnitude = norm(target_waypoint - current_pose)
    velocity_magnitude = norm(current_velocity)

    # 同时满足位置和速度条件
    if (position_error_magnitude < position_tolerance and
        velocity_magnitude < velocity_tolerance):
        # 发布航点到达信号
        waypoint_reached_msg.data = True
        waypoint_reached_pub.publish(waypoint_reached_msg)

        # 停止运动
        velocity_setpoint = [0, 0, 0]
```

## 姿态控制器 (Attitude Controller)

### 1. 功能概述

姿态控制器接收来自NMPC的姿态指令，通过PID控制算法计算所需的角速度指令，实现精确的姿态跟踪。

### 2. 输入输出接口

```python
# 输入话题
'/drone/control/attitude_command'           # Vector3Stamped - 目标姿态 [roll, pitch, yaw]
'/X3/odometry'                             # Odometry - 当前姿态状态
'/drone/control/attitude_enable'           # Bool - 控制器启用状态

# 输出话题
'/drone/control/angular_velocity_setpoint' # Vector3Stamped - 角速度设定点
'/drone/control/attitude_reached'          # Bool - 姿态到达状态
```

### 3. 姿态PID控制算法

```python
def control_loop(self):
    # 姿态误差计算 (角度归一化到[-π, π])
    attitude_error = np.zeros(3)
    for i in range(3):
        attitude_error[i] = normalize_angle(target_attitude[i] - current_attitude[i])

    # PID控制器参数 (参考PX4姿态控制器)
    kp = [kp_roll, kp_pitch, kp_yaw]      # 姿态比例增益
    ki = [ki_roll, ki_pitch, ki_yaw]      # 姿态积分增益
    kd = [kd_roll, kd_pitch, kd_yaw]      # 姿态微分增益

    # 积分项计算 (防积分饱和)
    attitude_error_integral += attitude_error * dt
    attitude_error_integral = clip(attitude_error_integral, -max_integral, max_integral)

    # 微分项计算
    error_derivative = (attitude_error - attitude_error_previous) / dt

    # PID输出计算
    angular_velocity_command = (kp * attitude_error +
                               ki * attitude_error_integral +
                               kd * error_derivative)

    # 角速度限制
    angular_velocity_command = clip(angular_velocity_command,
                                   -max_angular_velocity, max_angular_velocity)
```

### 4. 四元数到欧拉角转换

```python
def odometry_callback(self, msg):
    # 提取四元数
    quat = [msg.pose.pose.orientation.x,
            msg.pose.pose.orientation.y,
            msg.pose.pose.orientation.z,
            msg.pose.pose.orientation.w]

    # 转换为欧拉角 (roll, pitch, yaw)
    rotation = Rotation.from_quat(quat)
    self.current_attitude = rotation.as_euler('xyz', degrees=False)
```

### 5. 角度归一化处理

```python
def normalize_angle(self, angle):
    """将角度归一化到[-π, π]范围"""
    return math.atan2(math.sin(angle), math.cos(angle))

# 姿态误差计算中的角度处理
for i in range(3):
    attitude_error[i] = self.normalize_angle(
        self.target_attitude[i] - self.current_attitude[i]
    )
```

### 6. 参数配置

```python
# 控制频率 (高频率保证姿态响应性)
control_frequency: 100.0   # Hz

# 控制精度
attitude_tolerance: 0.1    # radians - 姿态到达容差

# PID增益 (参考PX4姿态控制器)
kp_roll: 4.0              # 滚转角比例增益
ki_roll: 0.0              # 滚转角积分增益
kd_roll: 0.2              # 滚转角微分增益
kp_pitch: 4.0             # 俯仰角比例增益
ki_pitch: 0.0             # 俯仰角积分增益
kd_pitch: 0.2             # 俯仰角微分增益
kp_yaw: 3.0               # 偏航角比例增益
ki_yaw: 0.0               # 偏航角积分增益
kd_yaw: 0.1               # 偏航角微分增益

# 角速度限制
max_angular_velocity_roll: 3.0   # rad/s
max_angular_velocity_pitch: 3.0  # rad/s
max_angular_velocity_yaw: 2.0    # rad/s
```

## 速度控制器 (Velocity Controller)

### 1. 功能概述

速度控制器是最底层的控制器，负责接收来自航点控制器和姿态控制器的速度/角速度指令，进行混合处理后输出最终的cmd_vel指令给Gazebo。

### 2. 输入输出接口

```python
# 输入话题
'/drone/control/velocity_setpoint'         # TwistStamped - 线速度设定点
'/drone/control/angular_velocity_setpoint' # Vector3Stamped - 角速度设定点
'/X3/odometry'                            # Odometry - 当前速度状态
'/drone/control/velocity_enable'          # Bool - 控制器启用状态

# 输出话题
'/X3/cmd_vel'                             # Twist - 最终控制指令
```

### 3. 多输入混合控制

```python
def control_loop(self):
    # 检查指令超时
    self._check_command_timeouts()

    # 速度平滑处理
    alpha = self.velocity_smoothing
    smoothed_velocity = (alpha * smoothed_velocity +
                        (1 - alpha) * target_velocity)
    smoothed_angular_velocity = (alpha * smoothed_angular_velocity +
                                (1 - alpha) * target_angular_velocity)

    # 速度误差计算
    velocity_error = smoothed_velocity - current_velocity
    angular_velocity_error = smoothed_angular_velocity - current_angular_velocity

    # PID控制
    kp_v = [kp_vx, kp_vy, kp_vz]
    kp_w = [kp_wx, kp_wy, kp_wz]

    acceleration_command = kp_v * velocity_error
    torque_command = kp_w * angular_velocity_error

    # 混合输出指令
    cmd_vel.linear.x = acceleration_command[0]
    cmd_vel.linear.y = acceleration_command[1]
    cmd_vel.linear.z = acceleration_command[2]
    cmd_vel.angular.x = torque_command[0]
    cmd_vel.angular.y = torque_command[1]
    cmd_vel.angular.z = torque_command[2]
```

### 4. 指令超时处理

```python
def _check_command_timeouts(self):
    """检查指令超时并重置为零指令"""
    current_time = self.get_clock().now()

    # 检查速度指令超时
    if self.velocity_command_active:
        time_diff = (current_time - self.last_velocity_command_time).nanoseconds / 1e9
        if time_diff > self.command_timeout:  # 0.5秒超时
            self.velocity_command_active = False
            self.target_velocity = np.zeros(3)

    # 检查角速度指令超时
    if self.angular_velocity_command_active:
        time_diff = (current_time - self.last_angular_velocity_command_time).nanoseconds / 1e9
        if time_diff > self.command_timeout:
            self.angular_velocity_command_active = False
            self.target_angular_velocity = np.zeros(3)
```

### 5. 速度限制与安全保护

```python
def apply_velocity_limits(self, cmd):
    """应用速度限制和安全保护"""
    # 水平线速度限制 (保持方向)
    linear_velocity_xy_mag = norm([cmd.linear.x, cmd.linear.y])
    if linear_velocity_xy_mag > self.max_linear_velocity_xy:
        scale_factor = self.max_linear_velocity_xy / linear_velocity_xy_mag
        cmd.linear.x *= scale_factor
        cmd.linear.y *= scale_factor

    # 垂直线速度限制
    cmd.linear.z = clip(cmd.linear.z, -max_linear_velocity_z, max_linear_velocity_z)

    # 角速度限制
    cmd.angular.x = clip(cmd.angular.x, -max_angular_velocity_xy, max_angular_velocity_xy)
    cmd.angular.y = clip(cmd.angular.y, -max_angular_velocity_xy, max_angular_velocity_xy)
    cmd.angular.z = clip(cmd.angular.z, -max_angular_velocity_z, max_angular_velocity_z)
```

### 6. 速度平滑处理

```python
# 平滑因子配置
velocity_smoothing: 0.3    # 0.0 = 无平滑, 1.0 = 完全平滑

# 平滑算法实现
smoothed_velocity = (alpha * smoothed_velocity +
                    (1 - alpha) * target_velocity)
```

### 7. 参数配置

```python
# 控制频率
control_frequency: 50.0    # Hz

# 平滑参数
velocity_smoothing: 0.3    # 速度平滑因子

# 速度限制 (参考PX4约束)
max_linear_velocity_xy: 3.0   # m/s - 水平最大线速度
max_linear_velocity_z: 2.0    # m/s - 垂直最大线速度
max_angular_velocity_xy: 3.0  # rad/s - 滚转/俯仰最大角速度
max_angular_velocity_z: 2.0   # rad/s - 偏航最大角速度

# PID增益
kp_vx: 0.5                # X轴速度比例增益
kp_vy: 0.5                # Y轴速度比例增益
kp_vz: 0.5                # Z轴速度比例增益
kp_wx: 0.3                # 滚转角速度比例增益
kp_wy: 0.3                # 俯仰角速度比例增益
kp_wz: 0.3                # 偏航角速度比例增益

# 安全参数
command_timeout: 0.5      # 秒 - 指令超时时间
```

## 控制器协调机制

### 1. 启用/禁用控制

每个控制器都有独立的启用/禁用机制：

```python
# NMPC节点统一控制所有低级控制器
def enable_callback(self, msg: Bool):
    self.control_enabled = msg.data

    # 启用/禁用所有低级控制器
    enable_msg = Bool()
    enable_msg.data = self.control_enabled

    self.waypoint_enable_pub.publish(enable_msg)
    self.attitude_enable_pub.publish(enable_msg)
    self.velocity_enable_pub.publish(enable_msg)
```

### 2. 控制流程时序

```
时刻 t:
1. NMPC计算最优控制 → 发布航点和姿态指令
2. 航点控制器(50Hz) → 计算速度设定点
3. 姿态控制器(100Hz) → 计算角速度设定点
4. 速度控制器(50Hz) → 混合并发布cmd_vel
5. Gazebo接收cmd_vel → 执行物理仿真

时刻 t+dt:
重复上述流程...
```

### 3. 故障处理机制

```python
# 1. 指令超时处理
if command_timeout:
    target_velocity = [0, 0, 0]
    target_angular_velocity = [0, 0, 0]

# 2. 控制器禁用处理
if not controller_active:
    send_zero_command()
    return

# 3. 状态数据缺失处理
if current_pose is None or target_waypoint is None:
    return  # 跳过控制循环

# 4. 积分饱和处理
error_integral = clip(error_integral, -max_integral, max_integral)
```

## 控制性能参数

### 1. 控制精度指标

```python
# 位置控制精度
position_tolerance = 0.2      # meters
velocity_tolerance = 0.1      # m/s

# 姿态控制精度
attitude_tolerance = 0.1      # radians (~5.7度)

# 控制响应时间
position_settling_time ≈ 2-3秒
attitude_settling_time ≈ 1-2秒
```

### 2. 控制带宽

```python
# 控制器频率配置
waypoint_controller: 50 Hz     # 位置控制
attitude_controller: 100 Hz    # 姿态控制 (高频)
velocity_controller: 50 Hz     # 速度混合

# 系统响应带宽
position_bandwidth ≈ 1-2 Hz
attitude_bandwidth ≈ 5-10 Hz
```

### 3. 稳定性裕度

```python
# PID参数调优原则 (参考PX4)
kp_position: 1.0    # 足够的跟踪性能
ki_position: 0.05   # 消除稳态误差
kd_position: 0.01   # 抑制振荡

kp_attitude: 4.0    # 快速姿态响应
ki_attitude: 0.0    # 避免积分饱和
kd_attitude: 0.2    # 增加阻尼
```

## 与Gazebo接口

### 1. cmd_vel指令格式

```python
# Twist消息结构
cmd_vel = Twist()
cmd_vel.linear.x    # 前进速度 (m/s)
cmd_vel.linear.y    # 侧向速度 (m/s)
cmd_vel.linear.z    # 上升速度 (m/s)
cmd_vel.angular.x   # 滚转角速度 (rad/s)
cmd_vel.angular.y   # 俯仰角速度 (rad/s)
cmd_vel.angular.z   # 偏航角速度 (rad/s)
```

### 2. 坐标系说明

```python
# 无人机体坐标系 (FRD: Front-Right-Down)
# X轴: 机头方向 (前进)
# Y轴: 右翼方向 (侧向右)
# Z轴: 向下方向 (下降)

# 世界坐标系 (ENU: East-North-Up)
# X轴: 东向
# Y轴: 北向
# Z轴: 上向
```

### 3. Gazebo物理仿真

Gazebo接收cmd_vel指令后，通过以下步骤执行：

1. **速度指令解析**: 将Twist消息解析为6DOF运动指令
2. **动力学仿真**: 根据无人机物理参数计算所需推力和力矩
3. **推进器分配**: 将总推力和力矩分配到各个旋翼
4. **物理积分**: 更新无人机位置、速度、姿态状态
5. **状态反馈**: 通过/X3/odometry话题发布当前状态

## 调试与监控

### 1. 性能监控话题

```python
# 状态监控话题
'/drone/control/waypoint_reached'     # 航点到达状态
'/drone/control/attitude_reached'     # 姿态到达状态
'/drone/control/velocity_setpoint'    # 速度设定点
'/drone/control/angular_velocity_setpoint'  # 角速度设定点

# 调试日志级别
DEBUG: 详细的控制误差和指令值
INFO:  控制器启用/禁用状态
WARN:  超时或异常情况
ERROR: 严重错误和故障
```

### 2. 性能分析

```bash
# 实时监控控制性能
ros2 topic echo /drone/control/velocity_setpoint
ros2 topic echo /X3/cmd_vel
ros2 topic hz /X3/odometry

# 查看控制器日志
ros2 node info waypoint_controller
ros2 node info attitude_controller
ros2 node info velocity_controller
```

## 总结

低级控制器系统通过分层架构实现了NMPC高级控制到Gazebo物理执行的完整映射：

1. **航点控制器**提供精确的位置跟踪能力
2. **姿态控制器**确保稳定的姿态控制响应
3. **速度控制器**实现安全可靠的指令执行

系统参考PX4飞控系统设计，具有良好的稳定性、响应性和鲁棒性，能够满足NMPC人员跟踪任务的控制需求。通过合理的参数调优和故障处理机制，确保无人机在各种工况下都能安全稳定地执行跟踪任务。